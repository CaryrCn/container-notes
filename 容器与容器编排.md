# 容器与容器编排

## 1. 容器

### 1.1 容器的定位

* 功能
  * **屏蔽运行环境的差异、应用间未隔离**，对应用部署运行的影响。（省去因环境不同而引入问题的成本）
  * 进而，提出的一种**将环境依赖和应用一起打包**成“集装箱”，并对不同应用进行**隔离**和对容器**限制**的模式。从而保证了即使运行在不同环境，还能保持一致的行为。

* 与虚拟机的不同之处
  * 虚拟机
    * 运行一个完整的 Guest OS 才能执行用户的应用进程，不可避免地带来了额外的资源消耗和占用
    * 虚拟机上的应用对操作系统的调用要经过虚拟化软件进行拦截和处理，转为真正宿主机上的系统调用
  * 容器
    * 一种通过namespace和cgroups进行隔离和限制的“特殊”进程，本质还是普通进程，没有虚拟化而带来的性能损耗，系统调用上，于其他进程无差异。
    * 性能优势
    * 缺点：隔离不彻底
      * 容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核
        1. 有很多资源和对象是不能被 Namespace 化的（时间）
           * 你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改
        2. 无法低版本的 Linux 宿主机上运行高版本的 Linux 容器
        3. 配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互,操作的是宿主机操作系统的内核

### 1.2 解决的问题

#### 1.2.1 **环境隔离（NameSpace）**

* 通过**Linux  NameSpace**技术，对 PID、Mount、UTS、IPC、Network 和 User进行隔离，达到隔离的应用只能看到当前NameSpace下的信息。

* | 分类                   | 系统调用参数  | 相关内核版本                                                 |
  | :--------------------- | :------------ | :----------------------------------------------------------- |
  | **Mount namespaces**   | CLONE_NEWNS   | [Linux 2.4.19](http://lwn.net/2001/0301/a/namespaces.php3)   |
  | **UTS namespaces**     | CLONE_NEWUTS  | [Linux 2.6.19](http://lwn.net/Articles/179345/)              |
  | **IPC namespaces**     | CLONE_NEWIPC  | [Linux 2.6.19](http://lwn.net/Articles/187274/)              |
  | **PID namespaces**     | CLONE_NEWPID  | [Linux 2.6.24](http://lwn.net/Articles/259217/)              |
  | **Network namespaces** | CLONE_NEWNET  | [始于Linux 2.6.24 完成于 Linux 2.6.29](http://lwn.net/Articles/219794/) |
  | **User namespaces**    | CLONE_NEWUSER | [始于 Linux 2.6.23 完成于 Linux 3.8)](http://lwn.net/Articles/528078/) |

* 涉及系统调用

  * **`clone`**() – 用来创建一个新的进程，并可以通过设计上述参数达到隔离。
  * **`unshare`**() – 使某进程脱离某个namespace
  * **`setns`**() – 把某进程加入到某个namespace。（注：**docker exec** 就是通过此系统调用加入对应容器的namespace实现）

* 命令行操作

  * 进入某个进程的namespace

    * ```
      nsenter -t ${pid} -i -m -n -p -u
      ```

* **`clone`**()使用 namespace 例子：

  * 基本代码（下列的例子都是通过在此代码基础上调整 main函数中clone的flag，和container_main函数即可）

    * ```
      #define _GNU_SOURCE
      #include <sys/types.h>
      #include <sys/wait.h>
      #include <stdio.h>
      #include <sched.h>
      #include <signal.h>
      #include <unistd.h>
      /* 定义一个给 clone 用的栈，栈大小1M */
      #define STACK_SIZE (1024 * 1024)
      static char container_stack[STACK_SIZE];
      char* const container_args[] = {
          "/bin/bash",
          NULL
      };
      int container_main(void* arg)
      {
          printf("Container - inside the container!\n");
          /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */
          execv(container_args[0], container_args); 
          printf("Something's wrong!\n");
          return 1;
      }
      int main()
      {
          printf("Parent - start a container!\n");
          /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */
          int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL);
          /* 等待子进程结束 */
          waitpid(container_pid, NULL, 0);
          printf("Parent - container stopped!\n");
          return 0;
      }
      ```

  * UTS Namespace

    * ```
      int container_main(void* arg)
      {
          printf("Container - inside the container!\n");
          sethostname("container",10); /* 设置hostname */
          execv(container_args[0], container_args);
          printf("Something's wrong!\n");
          return 1;
      }
      int main()
      {
          printf("Parent - start a container!\n");
          int container_pid = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */
          waitpid(container_pid, NULL, 0);
          printf("Parent - container stopped!\n");
          return 0;
      }
      ```

      * 运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container

      * ```
        root@container:~# hostname
        container
        root@container:~# uname -n
        container
        ```

  * PID namespaces

    * ```
      int container_main(void* arg)
      {
          /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */
          printf("Container [%5d] - inside the container!\n", getpid());
          sethostname("container",10);
          execv(container_args[0], container_args);
          printf("Something's wrong!\n");
          return 1;
      }
      int main()
      {
          printf("Parent [%5d] - start a container!\n", getpid());
          /*启用PID namespace - CLONE_NEWPID*/
          int container_pid = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL); 
          waitpid(container_pid, NULL, 0);
          printf("Parent - container stopped!\n");
          return 0;
      }
      ```

      * 查看运行结果

        ```
        echo $$ 
        1
        ```

  * Mount namespaces

    * ```
      int container_main(void* arg)
      {
        printf("Container - inside the container!\n");
        // 如果你的机器的根目录的挂载类型是 shared，那必须先重新挂载根目录
        // mount("", "/", NULL, MS_PRIVATE, "");
        mount("none", "/tmp", "tmpfs", 0, "");
        execv(container_args[0], container_args);
        printf("Something's wrong!\n");
        return 1;
      }
      ```

    * ```
      ls /tmp
      ```

* NameSpace实现

  * 使用
    * 用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，选择是否开启一个新的namespace
  * 原理分析（待补充）
    * 

#### 1.2.2 **限制（Cgroups）**

* 额外说明：

  * 当前描述的版本为cgroups-v1，也是大多数生产环境使用的版本，使用简单，但管理上特别是层级复杂且多的时候不易管理，后续推出了v2版本 见以下链接
    * 推出v2版本的原因：https://lwn.net/Articles/484251/
    * v2版本unified control group hierarchy：https://lwn.net/Articles/601840/

* 引入限制的原因

  * 因为本质还是宿主机上的普通进程，那么还是会和其他进程存在资源相互抢占的情况，为了避免容器进程与其他进程间的相互影响，引入了资源限制这一功能（通过**Cgroups**实现）

* **Linux Cgroups** （**Linux Control Group**）

  * 功能

    * **限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽**
    * 优先级设置、审计、将进程挂起和恢复等

  * 概述

    * Cgroups 通过文件系统的形式提供限制的功能，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下

    *  /sys/fs/cgroup 下的目录结构

      * ```
        [root@VM_0_4_centos cgroup]# ls
        blkio    cpu,cpuacct  freezer  net_cls           perf_event
        cpu      cpuset       hugetlb  net_cls,net_prio  pids
        cpuacct  devices      memory   net_prio          systemd
        ```

      * 表示可以被限制的类型有哪些: cpuset、cpu、 memory 等

    * /sys/fs/cgroup/cpu下的目录结构

    * ```
      $ ls /sys/fs/cgroup/cpu
      cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release
      cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks
      ```

      * 表示cpu可以被具体控制的参数有哪些 cpu.cfs_period_us （cpu周期，单位us，默人100ms） 、cpu.cfs_quota_us（使用的cpu，单位us，默人不限制-1），
        * 这两个参数需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。
          * 如cpu.cfs_quota_us设置成20ms，则表示100ms内最多只能分配到100ms的cpu执行时间，即最高占用cpu 20%

  * 使用

    1. 在需要资源限制的目录下面创建文件夹

       * 如：想对cpu进行限制，则在Cpu下面创建一个文件夹（**即：创建一个控制组**）

         * ```
           /sys/fs/cgroup/cpu$ mkdir container
           ```

       * 此时，创建的文件夹下，自动会生成对应的文件如下所示

         * ```
           root@ubuntu:/sys/fs/cgroup/cpu$ ls container/
           cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release
           cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks
           ```

         * 即与之前/sys/fs/cgroup/cpu下的内容一致

    2. 可对此控制组进行资源限制

       * 如cpu.cfs_quota_us设置成20ms，则表示100ms内最多只能分配到100ms的cpu执行时间，即最高占用cpu 20%

         * ```
           $ echo 20000 > /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
           ```

         * 此时，此控制组下的任务cpu使用率最高为20%

    3. 添加进程到此控制组，进行限制

       * ```
         echo ${pid} > /sys/fs/cgroup/cpu/container/tasks 
         ```

         * ${pid} 即为要限制的进程pid，此时限制已生效，进程此时的cpu最高使用率为20%

       * 验证是否生效

         * 后台执行脚本（死循环），进程id：1186

           ```
           while : ; do : ; done &
           [1] 1186
           ```

         * 查看cpu系统占用为100%

         * 执行 echo  1186 > /sys/fs/cgroup/cpu/container/tasks （把此进程加入上述添加的限制组中）

         * 查看系统占用为20%，说明资源限制生效

  * docker 中的使用：

    * ```
      docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash
      ```

      * -it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联

    * 查看是否生效

      * ```
        $ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_period_us 
        100000
        $ cat /sys/fs/cgroup/cpu/docker/5d5c9f67d/cpu.cfs_quota_us 
        20000
        ```

* 原理概述 

  * 1. 首先是cgroup的初始化，在系统初始化start_kernel()时发生。

    * **主要的作用**：初始化 cgroup 的各个子系统的操作函数，分配各个子系统的数据结构

  * 2. mount cgroup 文件系统，创建文件系统的树形结构，以及操作函数
       * 对于不同的类型，这里的op操作指针指向不同的函数，达到写cpu下的文件和写memory的文件，调用不同的函数，对于同个cpu下的不同参数如cfs_quota_us和cfs_period_us也是不同的函数调用

  * 3. 写入 cgroup 文件，设置 cpu 或者 memory 的相关参数，这个时候文件系统的操作函数会调用到 cgroup 子系统的操作函数，从而将参数设置到 cgroup 子系统的数据结构中

  * 4. 写入 tasks 文件，将进程交给某个 cgroup 进行管理，因为 tasks 文件也是一个 cgroup 文件，统一会调用文件系统的操作函数进而调用 cgroup 子系统的操作函数，将 cgroup 子系统的数据结构和进程关联起来

  * 5. 对于 cpu 来讲，会修改 scheduled entity，放入相应的队列里面去，从而下次调度的时候就起作用了。对于内存的 cgroup 设定，只有在申请内存的时候才起作用
       * scheduled entity结构体说明：
         * 这个是完全公平调度算法的调度实体，是绝大多数进程的调度算法，此结构体就是记录进程的执行调度情况，包括vruntime运行时间、权重等统计，是linux调度队列（是个红黑树 ）上的节点，与进程task_struct 一一对应。

    

#### 1.2.3 环境依赖的一致性保证（切换进程的根目录）

* 如何保证环境依赖的一致？

  * 只要我依赖的lib、配置、目录、文件一致是不是就意味着环境一致。
  * 所以只要我挂载的根目录文件系统rootfs每次都相同，就可以保证我的环境一致。

* 解决方案

  * 为容器进程挂载一个新的rootfs与原宿主机上的rootfs隔离，且运行时都挂载相同的文件系统，即可保证环境一致。

  * Mount Namespace

    * <span name = "说明">说明</span>

      * 用 clone() 创建进程并设置开启了mount namespace时，父进程会把自己的**文件结构复制给子进程**中。而**子进程需要重新挂载才能生效（不然还是用父进程里复制来的文件结构），且子进程新的namespace中的所有mount操作都只影响自身的文件系统，而不对宿主机不会产生任何影响**

    * 通过Mount Namespace隔离挂载一个完整的操作系统**rootfs（根文件系统）**，即切换进程的根目录至新的完整操作系统的文件和目录，可实现上述的环境和依赖保持一致。这里的rootfs即为我们所说的**“容器镜像”**。会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等

      * 注：**rootfs 只是一个操作系统所包含的文件、配置和目录并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像**，所以会存在配置内核参数影响全局的情况

      * ```
        $ ls /
        bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var
        ```

    * 【课外阅读】

      * 因为mount namespace间存在隔离，对于一个新的disk，如果多个namespace都需要可见，那么对于每个namespace都需要执行下mount的操作，有没有什么解决方案呢

        * #### Shared subtrees

* 还需要解决的问题：

  * 多容器对rootfs（完整操作系统文件和目录）的复用性问题，需做到复用且又隔离互不影响
  * 解决方案：**分层（layer）设计**	

* **分层（layer）设计**	

  * 概述：

    * 对于公共不变化的部分，保持只读 （**只读层**）；对于变化（增量写入操作的部分），保持读写（**读写层**）；再将这样的**文件进行叠加，给用户展现叠加后的最终的rootfs视图**，这样就做到了复用与隔离。
    * 实际上还有一层**Init 层**，**用来存放启动容器时的值，这类数据有个特点，与镜像无关，仅本次容器启动生效，执行docker commit时，也不会提交**。

  * 对于叠加功能的实现，需要**联合文件系统（Union File System**）的能力

    * 功能

      * 将多个不同位置的目录联合挂载（union mount）到同一个目录下

    * 例子：

      * 文件当前目录

        * ```
          $ tree
          .
          ├── A
          │  ├── a
          │  └── x
          └── B
            ├── b
            └── x
          ```

      * 联合两个目录A、B到C目录下

        * ```
          $ mkdir C
          $ mount -t aufs -o dirs=./A:./B none ./C
          $ tree ./C
          ./C
          ├── a
          ├── b
          └── x
          ```

        * 即完成了目录的合并

* Docker中的**联合文件系统（Union File System**）

  * 如果是**AuFS**实现的联合文件系统目录结构在 /var/lib/docker 路径下的 diff 目录	

    * ```
      /var/lib/docker/aufs/diff/<layer_id>
      ```

  * 通过查看挂载的方式，查看具体使用的联合文件系统

    * ```
      cat /proc/mounts
      ```

  * 例子实践

    1. 启动一个容器

       * ```
         docker run -d ubuntu:latest sleep 3600
         ```

       * 此时Docker 就会从 Docker Hub 上拉取一个 Ubuntu 镜像（ Ubuntu 操作系统的所有文件和目录）到本地，通过如下命令查看

         * ```
           $ docker image inspect ubuntu:latest
           ...
                "RootFS": {
                 "Type": "layers",
                 "Layers": [
                   "sha256:f49017d4d5ce9c0f544c...",
                   "sha256:8f2b771487e9d6354080...",
                   "sha256:ccd4d61916aaa2159429...",
                   "sha256:c01d74f99de40e097c73...",
                   "sha256:268a067217b5fe78e000..."
                 ]
               }
           ```

         * 此时有五个增量 rootfs，每一层都是 Ubuntu 操作系统文件与目录的一部分；而在使用镜像时，Docker 会把这些增量联合挂载在一个统一的挂载点上，即 **/var/lib/docker/aufs/mnt/**路径（**AuFS**实现的联合文件系统下才是这个路径）

         * 具体以docker版本为准，通过**docker image inspect ${container_id}**查看

           * ```
             笔者环境:为"MergedDir"路径
             $ docker inspect a06f395c54a5 
             ···
             "GraphDriver": {
                         "Name": "overlay2",
                         "Data": {
                             "LowerDir": "/var/lib/docker/overlay2/26b570d4e3f93a9158864d4b29a0b528e16d410b87bacf723588ff75736fb464-init/diff:/var/lib/docker/overlay2/100048e4650f53dbebccdbf03121694a98fba0b7c5c950d933227a8c247a8d24/diff",
                             "MergedDir": "/var/lib/docker/overlay2/26b570d4e3f93a9158864d4b29a0b528e16d410b87bacf723588ff75736fb464/merged",
                             "UpperDir": "/var/lib/docker/overlay2/26b570d4e3f93a9158864d4b29a0b528e16d410b87bacf723588ff75736fb464/diff",
                             "WorkDir": "/var/lib/docker/overlay2/26b570d4e3f93a9158864d4b29a0b528e16d410b87bacf723588ff75736fb464/work"
                         }
                     },
             ···
             ```

           * 此路径下即为完整的 Ubuntu 操作系统

             

  * <span name="123rootfs层级结构">**Docker rootfs层级结构**</span>

    * ![下载](容器与容器编排.assets/下载.png)
    * **只读层**
      * 它们的挂载方式都是只读的（ro+wh，即 readonly+whiteout）
        * whiteout说明：
          * 因为是增量覆盖，所以对于删除的支持，需要特殊处理，为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来，达到删除的功能
    * **可读写层**
      * 它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层
      * 可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上
    * **Init 层**
      * 以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息
      * 用户往往需要在**启动容器**时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。
      * **用户执行 docker commit 只会提交可读写层，是不包含这些内容的**
    * 说明：
      * 最终,联合挂载到对应目录下，通过相同的文件上层会覆盖掉下层。所以通过上层读写层，init层覆盖一层一层覆盖的方式，达到隔离和复用的效果

#### 1.2.4 容器内外目录映射（**Volume 机制**）

* 功能：容器对宿主机文件的读取和修改，并且在docker commit时，不会提交挂载文件

* 实现方式

  * 通过在创建mount namespace之后，挂载文件切换进程根目录之前，执行 mount bind 操作将向映射文件，挂载到容器目标路径下。（因此时还未挂载文件，可以读到宿主机文件路径，且开启了mount namespace挂载对宿主机无感知，不会影响宿主机，<a href="#说明">详见1.2.3环境依赖的一致性保证-解决方案-mount space说明</a>)

*  mount bind

  * 说明
    * 将一个目录或者文件，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。
    * ![bind](容器与容器编排.assets/bind.png)
    * 相当于将 /test 的 dentry，重定向到了 /home 的 inode。这样当我们修改 /test 目录时，实际修改的是 /home 目录的 inode。这也就是为何，一旦执行 umount 命令，/test 目录原先的内容就会恢复：因为修改真正发生在的，是 /home 目录里。

* docker commit不会提交挂载文件的解释

  * commit发生在宿主机空间，是对**容器rootfs在宿主机实际的文件路径**下的读写层的提交（如联合文件系统为**AuFS**时，路径：/var/lib/docker/aufs/diff, <a href="#123rootfs层级结构">详见1.2.3环境依赖的一致性保证-Docker rootfs层级结构</a>）。而由于 Mount Namespace 的隔离作用，宿主机并不知道这个/test文件路径重新被 mount bind到了/home下（开启了mount namespace 所以mount操作对宿主机隔离，只在容器内生效），所以看到的是个空的/test文件夹，所以不会提交挂载的文件。

* 例子验证

  * 启动容器，挂载/test文件夹，并在此路径下创建文件

    * ```
      $ docker run -it -v /test busybox /bin/sh
        touch /test/text.txt
      ```

    * 对于没有指定宿主机挂载位置的数据卷，挂载的默认路径为  **/var/lib/docker/volumes/[VOLUME_ID]/_data**

  * 查看挂载卷下是否有此文件（预期：有）

    * ```
      $ docker volume ls
      DRIVER              VOLUME NAME
      local               966520d40b36cc345a88814
      
      $ ls /var/lib/docker/volumes/966520d40b36cc345a88814/_data/
      text.txt
      ```

    * 可以通过docker volume ls命令获取VOLUME ID，默认路径为/var/lib/docker/volumes/[VOLUME_ID]/_data/

    * 也可以直接通过命令 docker inspect ${container_id}获取

  * 查看容器rootfs在宿主机实际的文件路径下是否有此文件（预期：无）

    * ```
      $ docker inspect b7b5922db1cf
      ···
       "MergedDir": "/var/lib/docker/overlay2/9e42bf5e2f7aabe5dc15a0fe0846a5874f530eedf3481189096b236c210b0db8/merged",
      ···
      [root@VM_0_4_centos ~]# cd /var/lib/docker/overlay2/9e42bf5e2f7aabe5dc15a0fe0846a5874f530eedf3481189096b236c210b0db8/merged/test
      [root@VM_0_4_centos test]# ll
      总用量 0
      ```

    * 通过docker inspect ${container_id}获取 rootfs路径，查看路径下的/test文件夹，不存在text.txt，与预期一致，验证完毕。

    * 如果docker版本用的是Aufs联合文件系统，rootfs默认路径为/var/lib/docker/aufs/mnt下

### 1.3 Docker使用

#### 1.3.1 Dockerfile （**制作容器镜像**）

* 实现
  * **使用一些标准的原语（即大写高亮的词语），描述我们所要构建的 Docker 镜像。并且这些原语，都是按顺序处理**
    * **Dockerfile 中的每个原语执行后，都会生成一个对应的镜像层**。即使原语本身并没有明显地修改文件的操作（比如，ENV 原语），它对应的层也会存在。只不过在外界看来，这个层是空的

* 例子

  * ```
    # 使用官方提供的 Python 开发镜像作为基础镜像,免去了安装 Python 等语言环境
    FROM python:2.7-slim
     
    # 将工作目录切换为 /app,Dockerfile 后面的操作都以这一句指定的 /app 目录作为当前目录。
    WORKDIR /app
     
    # 将当前目录下的所有内容复制到 /app 下
    ADD . /app
     
    # 使用 pip 命令安装这个应用所需要的依赖
    RUN pip install --trusted-host pypi.python.org -r requirements.txt
     
    # 允许外界访问容器的 80 端口
    EXPOSE 80
     
    # 设置环境变量
    ENV NAME World
     
    # 设置容器进程为：python app.py，即：这个 Python 应用的启动命令
    CMD ["python", "app.py"]
    ```

    * RUN 原语就是在容器里执行 shell 命令
    *  ENTRYPOINT 的原语。实际上，它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：“ENTRYPOINT CMD”
      * 默认情况下，Docker 会为你提供一个隐含的 ENTRYPOINT，即：/bin/sh -c。所以，在不指定 ENTRYPOINT 时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c “python [app.py](http://app.py)”，即 CMD 的内容就是 ENTRYPOINT 的参数
      * 基于以上原因，**我们后面会统一称 Docker 容器的启动进程为 ENTRYPOINT，而不是 CMD**

